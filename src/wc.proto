syntax = "proto2";

// Position vectors optimized for values not close to 0
message FixedVector {
        required sfixed32 x = 1;
        required sfixed32 y = 2;
        required sfixed32 z = 3;
}

// Wing commander stored orientations as 32-bit from -256 to 256 inclusive
message Vector {
        required sint32 x = 1;
        required sint32 y = 2;
        required sint32 z = 3;
}

message Location {
        optional FixedVector pos = 1;
        optional Vector vel = 2;
        optional Vector right = 3;
        optional Vector up = 4;
        optional Vector fore = 5;
        optional uint32 set_speed = 6;
}

message Damage {
        optional Vector pos = 1;
        optional uint32 shooter = 2; // 16 bits
        optional uint32 quantity = 3; // 16 bits
        optional uint32 ship_id = 4;
        optional fixed32 seed = 5;
}

message WeaponFire {
        optional uint32 gun_id = 1; // 4 bits
        optional uint32 shooter = 2;
        optional uint32 ship_id = 3; // if missile, which id?
}

message Spawn {
        optional uint32 mission_ship_id = 1;
        optional uint32 situation_id = 2;
        optional uint32 ship_id = 3;
        optional fixed32 seed = 5;
}

message Despawn {
        optional uint32 ship_id = 1;
        optional uint32 shooter = 2;
        optional uint32 explode = 3;
}

message ShipUpdate {
        optional uint32 ship_id = 1; // 16 bits
        optional Location loc = 2;

        optional string callsign_update = 255;
}

enum GameState {
     Proceed = 0;
     EndLand = 1;
     EndEject = 2;
     EndCarrier = 3;
     EndDeath = 4;
     EndExit = 5;
}

enum AutoPilotState {
     Disengaged = 0;
     Engaged = 1;
     Finished = 2;
}

message AutoPilotEvent {
   optional uint32 cam_ship_type = 1;
   optional uint32 cam_mode = 2;
   optional uint32 duration = 3;
   optional bool finish_camera = 4;
}

message Event {
  optional string chat = 1;
  optional Spawn spawn = 2;
  optional Damage damage = 3;
  optional WeaponFire fire = 4;
  optional Despawn despawn = 5;
  optional AutoPilotEvent autopiloting = 16;
}

message MissionEnd {
    optional GameState game_update = 1;
    optional bytes mission_tree_progress = 2;
}

message Frame {
    repeated ShipUpdate update = 1; // one update per updated ship
    repeated Event event = 2;
    optional MissionEnd mission_end = 18;
}

// Connect -> once per mission
message Connect {
    optional string callsign = 1;
}

message Game {
    optional uint32 mission_id = 1;
    required uint32 assigned_player_id = 2;
    optional Frame starting_state = 3;
}

message NetworkMessage {
    optional Connect connect = 1;
    optional Game game = 2;
    optional Frame frame = 3;
}
